BeginPackage["DataPacletTools`BuildTools`JenkinsAutomation`JenkinsSetup`"]

(* An empty stub file is created if no push occurs so that jenkins does not fail when it 
finds no files in its out directory *)
runPush::usage = "";
(*[paclet_String, version_String, origin_String, destination_String, workspace_String] := Module[{viable},
	If[origin==="localhost",
		dumpAndPushToHead[paclet, version, workspace];
		viable = CheckProductionHEADViability[paclet];
		If[viable=!=True,
    		logPrint["ERROR", "Paclet failed viability check!"];
    		Exit[1];
    	];
    	pushToProduction[paclet, "HEAD", destination];,
    	pushToProduction[paclet, origin, destination];
	];
    logPrint["INFO", "Push Finished"];
]*)

runBatchPrep::usage = "";
(*[origin_String, destination_String, additions_List, omissions_List, workspace_String] := Module[{pushFile, dbsToPush, stagingElements},
	pushFile = FileNameJoin[{workspace, "pushfile.txt"}];
	dbsToPush = ProductionPushPrep[origin, destination][[2]];
	stagingElements = Select[dbsToPush, StringMatchQ[#, __ ~~ "staging"] &];
	If[Length[stagingElements] > 0,
		Scan[logPrint["INFO", "staging paclet "<>#<>" found!"] &, stagingElements];
		logPrint["INFO", "Adding Production Exclusions..."];
		AddProductionExclusion/@stagingElements;
		dbsToPush = Complement[dbsToPush, stagingElements];
	];
	dbsToPush = Union[dbsToPush, additions];
	dbsToPush = Complement[dbsToPush, omissions];
	logPrint["INFO","Adding the following paclets to pushfile:"];
	Scan[Print[#] &, dbsToPush];
	Put[dbsToPush, pushFile];
	logPrint["INFO","Batch Push Prep Complete!"]
]*)

runBatchPush::usage = "";
(*[origin_String, destination_String, workspace_String] := Module[{pushFile, dbsToPush, diffs, dbsNotPushed, failedPushes},
	pushFile = FileNameJoin[{workspace, "pushfile.txt"}];
	dbsToPush = Get[pushFile];
	If[MemberQ[dbsToPush, "CalculateDataCloud"],
		logPrint["INFO","CalculateDataCloud will be run in a separate executor. Removing..."];
		dbsToPush = DeleteCases[dbsToPush,"CalculateDataCloud"];
	];
	logPrint["INFO","Initiating batch push..."];
	Scan[pushToProduction[#, origin, destination] &, dbsToPush];
	logPrint["INFO","Paclet push complete, performing validation of push..."]
	If[MemberQ[dbsToPush, "CalculateGeoIPData"],
		logPrint["INFO","Performing diff check on CalculateGeoIPData..."];
		diffs = DiffCountReportsForProductionPaclet["CalculateGeoIPData", origin, destination];
		If[Length[diffs] > 0,
			logPrint["ERROR", "Differences found in GeoIPData..."];
			Print[diffs];
			logPrint["ERROR", "Please re-run push for GeoIPData, continuing..."],
			logPrint["INFO", "No diffs found, continuing..."];
		];
		dbsToPush = DeleteCases[dbsToPush,"CalculateGeoIPData"];
	];
	logPrint["INFO","Re-running ProductionPushPrep..."];
	dbsNotPushed = ProductionPushPrep[origin, destination][[2]];
	dbsNotPushed = DeleteCases[dbsNotPushed, #] & /@ {"CalculateGeoIPData","CalculateDataCloud"};
	failedPushes = Intersection[dbsToPush, dbsNotPushed];
	If[Length[failedPushes] > 0,
		Scan[logPrint["ERROR",#<>" failed to push or was recently updated!!"] &, failedPushes];
		Exit[1];
	];
	logPrint["INFO", #<>" now shows up as a diff but did not during initial prep, consider pushing..."] & /@ dbsNotPushed;	
	logPrint["INFO","Batch Push Finished!"];
]*)
	
runCompile::usage = "";
(*[paclet_String, version_String, workspace_String] := Module[{res, rules},
	DataPacletTools`Utilities`GetConfiguration["OutputDirectory"] = workspace;
	res = Check[rules = compilePaclet[paclet, version, workspace], $Failed];
	logPrint["INFO", "Compile output: \n", TableForm[List@@@rules], "\n\n"];
	If[(res===$Failed && paclet=!="CityData")|| Not[MatchQ[rules, {__Rule}]], 
          logPrint["ERROR", "Compile error!"]; 
          Exit[1] 
     ]; 
    logPrint["INFO", "Build Finished"];
]*)

runLocalize::usage = "";
(*[paclet_String, version_String, workspace_String, language_String] := Module[{res, rules},
	DataPacletTools`Utilities`GetConfiguration["OutputDirectory"] = workspace;
	res = Check[rules = compileLocalizedPaclet[paclet, version, workspace, language], $Failed];
	logPrint["INFO", "Compile output: \n", TableForm[List@@@rules], "\n\n"];
	If[res===$Failed || Not[MatchQ[rules, {__Rule}]], 
          logPrint["ERROR", "Compile error!"]; 
          Exit[1] 
     ]; 
    logPrint["INFO", "Build Finished"];
    deployLocalizationToHead[paclet, version, language];
]*)

Begin["`Private`"]

Needs["JLink`"];
ReinstallJava[JVMArguments -> "-Xmx4096m"] (* Was "-Xmx8192m" *) 
    
Print["************ Loading re_jenkins_setup.m ****************"];

Needs["DataPacletTools`"];
Needs["DataPacletTools`FeedTools`FeedUtilities`"];

getFileName[s_String] := Last@StringSplit[s, $PathnameSeparator]

Print["Process ID is "<>ToString[$ProcessID]];

bashExecute[exec_String] := Module[{cmd},
	cmd = "/bin/bash -l -c '"<> exec <> "'";
	logPrint["INFO", cmd];
	Run[cmd]===0
]


(* System`CopyFile[] doesn't overwrite destination *) 
copyFile[in_String, out_String] := Module[{}, 
	If[FileType[in]=!=File, Return[$Failed]]; 
    If[FileType[out] === Directory,
    	(* Target is a directory *) 
        logPrint["INFO", "Copying ", in, " -> ", ToFileName[out, getFileName[in]]];
        Export[ToFileName[out, getFileName[in]], Import[in, "String"], "String"],
         
        (* Target is a file *)                             
        logPrint["INFO", "Copying ", in, " -> ", out];
        Export[out, Import[in, "String"], "String"]
    ]
]

compileRepositoryPaclet[paclet_String, version_String, workspace_String] := (    
    CompilePaclet[FindCollection[paclet], "Alpha",     	
    	"PacletVersion" -> version,    	
    	Sequence@@pacletBuildOptions[paclet]
    ]
)


compileCVSPaclet[paclet_String, version_String, workspace_String] := Module[{files, res},
	res = checkoutSources[paclet, workspace];	
	files = Sort@FileNames["*.m", FileNameJoin[{workspace, "Source"}], Infinity];
	files = filterFiles[paclet, files];
	logPrint["INFO", "Compiling the following files: ", InputForm@files];	
	CompilePaclet["Database", paclet, files, 		
		"PacletVersion"-> version,
		Sequence@@pacletBuildOptions[paclet]
	] 
]

compilePaclet[paclet_String, version_String, workspace_String] := Module[{}, 
    If[IsCollectionActive[paclet], 
        logPrint["Starting Repository build for ", paclet, " - Version ", version];
        compileRepositoryPaclet[paclet, version, workspace], 
        
        logPrint["Starting CVS build for ", paclet,  " - Version ", version];
        compileCVSPaclet[paclet, version, workspace]
    ]
]

(* Adapted from joshuam's FeedTools/BuildPacletFunctions.m, filterFiles is not used,
   expecting *.filter. Should be restructured to allow custom build options... *)
compileLocalizedPaclet[paclet_String, version_String, workspace_String, language_String] := Module[{files,
		checkoutTarget, originalPaclet, rules, con, tablePostfix, tables},
	checkoutTarget = StringReplace[paclet, "Localized" -> "/Localization"];
	res = checkoutSources[checkoutTarget, workspace];
	logPrint["INFO", "Loading filter files: ", FileNames["*.filter", workspace]];
	Get /@ FileNames["*.filter", workspace];
	files = Sort@FileNames["*.m", FileNameJoin[{workspace, "Source", language}], Infinity];
	logPrint["INFO", "Compiling the following files: ", InputForm@files];
	originalPaclet = StringReplace[paclet, "Localized" -> ""];
	CompilePaclet["Database", originalPaclet, files,
		"PacletVersion" -> version,
		"DatabaseName" -> "Calculate"<>paclet,
		Sequence@@pacletBuildOptions["Localized"]
	]
]
		

compilePaclet[args___] :=(logPrint["ERROR", "Bad arguments to compilePaclet[] ", {args}]; Exit[1];) 

   	  
   	  
logStats[rules_] := (
    logPrint["INFO", "EntityCount: ", "EntityCount" /. rules];
    logPrint["INFO", "PropertyCount: ", "PropertyCount" /. rules];
    logPrint["INFO", "GroupCount: ", "GroupCount" /. rules];
)


checkoutSources[paclet_String, workspace_String] := Module[{script},
    script = FileNameJoin[{workspace, "DataPacletTools", "BuildTools", "PacletCompile", "scripts", "pacletcheckout.sh"}];
    If[!bashExecute[script<>" "<>workspace<>" "<>paclet], 
        logPrint["ERROR", "Error during checkout of ", paclet];
        Exit[1];
    ]
]

deployLocalizationToHead[paclet_String, versiong_String, language_String] := Module[{con, dbName, 
		originalPaclet, originalVersion, tablePostfix, existingDump, tables, out, sqlfile, res},
	logPrint["INFO", "Deploying build..."];
	con = GetMySQLConnection[GetLocalAuthentication[]];
	dbName = "Calculate"<>paclet;
	originalPaclet = StringReplace[dbName, "Localized" -> ""];
	tablePostfix = ToLowerCase@StringReplace[language, "-" -> "_"];
	JSQLExecute[con, False, "USE "<>dbName];
	JSQLExecute[con, False, "RENAME TABLE data to data_"<>tablePostfix];
    JSQLExecute[con, False, "RENAME TABLE info to info_"<>tablePostfix];
    tables = {"data_"<>tablePostfix,"info_"<>tablePostfix};
    CloseSQLConnection[con];
    
    (* Now, we dump the paclet from localhost *)
    out = FileNameJoin[{workspace, "out"}];
    If[FileType[out] =!= Directory, CreateDirectory[out]];
	sqlfile = FileNameJoin[{workspace, "out", dbName<>"-"<>version<>".sql"}];
	logPrint["INFO", "Dumping ", dbName];
	res = DataPacletTools`AlphaProductionVersioning`Private`DumpFromDatabase[GetLocalAuthentication[], dbName, sqlfile, tables, True];
	If[!TrueQ[res],
        logPrint["ERROR", "Error dumping build!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    (* Check devel to make sure the base paclet exists so we don't throw an unhandled error *)
    If[MemberQ[ListDatabasesOnProductionTarget["devel"], originalPaclet], 
    	originalVersion = GetProductionPacletInfoEntry["devel", originalPaclet, "Version"], 
     	logPrint["ERROR", "Original paclet not found!"];
    Exit[1];
    ];
    logPrint["INFO", "Dumping ", originalPaclet];
    existingDump = FileNameJoin[{workspace, "out", originalPaclet<>"-"<>originalVersion<>".sql"}];
    res = DumpProductionTargetPaclet[originalPaclet, "devel", existingDump];
    If[! TrueQ[res],
        logPrint["ERROR", "Error dumping existing paclet from CURRENT!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    
    (* Create database if it doesn't exist TODO: check if necessary *)
    con = GetProductionConnection[];
    JSQLExecute[con, False, "CREATE DATABASE IF NOT EXISTS "<> dbName];
    CloseSQLConnection[con];
    
    auth = GetProductionAuthentication[];
    
    logPrint["INFO", "Pushing ", dbName, " to HEAD"];
    res = DumpIntoDatabase[auth, dbName, sqlfile];
    If[! FreeQ[res, $Failed],
        logPrint["ERROR", "Error pushing build to HEAD!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    res = DumpIntoDatabase[auth, dbName, existingDump];
    If[! FreeQ[res, $Failed],
        logPrint["ERROR", "Error pushing base tables to HEAD!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    
    logPrint["INFO", "\nCompressing dump files\n"];
    If[!bashExecute["gzip "<>sqlfile], 
    	logPrint["ERROR", "Error compressing dump file"];
    	Exit[1];
    ];
    If[!bashExecute["gzip "<>existingDump], 
    	logPrint["ERROR", "Error compressing base table dump file"];
    	Exit[1];
    ];    
]

dumpAndPushToHead[paclet_String, version_String, workspace_String] := Module[{sqlfile, tables, con, dbName, res},
	dbName = "Calculate"<>paclet;
	con = GetMySQLConnection[GetLocalAuthentication[]];
	tables = Flatten[JSQLExecute[con, False, "SHOW TABLES FROM " <> dbName]];
	sqlfile = FileNameJoin[{workspace, "out", dbName<>"-"<>version<>".sql"}];
	logPrint["INFO", "Dumping ", dbName];
	res = DataPacletTools`AlphaProductionVersioning`Private`DumpFromDatabase[GetLocalAuthentication[], dbName, sqlfile, tables, True];
	If[!TrueQ[res],
        logPrint["ERROR", "Error dumping build!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    logPrint["INFO", "Pushing ", dbName, " to HEAD"];
    res = PushToProductionHead[dbName, sqlfile];
    If[! FreeQ[res, $Failed],
        logPrint["ERROR", "Error pushing build to HEAD!"];
        logPrint["ERROR", res];
        Exit[1];
    ];
    logPrint["INFO", "\nCompressing dump file\n"];
    If[!bashExecute["gzip "<>sqlfile], 
    	logPrint["ERROR", "Error compressing dump file"];
    	Exit[1];
    ];    
]

pushToProduction[paclet_String, origin_String, destination_String] := Module[{dbName, res},
	If[StringMatchQ[paclet, "Calculate*"],
		dbName = paclet;,
		dbName = "Calculate"<>paclet;
	];
    logPrint["INFO", "Pushing ", dbName, " from "<>origin<>" to "<>destination];
    res = ProductionPushRuntime[origin, destination, dbName];
    If[! FreeQ[res, $Failed],
        logPrint["ERROR", "Error pushing build to "<>destination<>"!"];
        logPrint["ERROR", res];
        Exit[1];
    ];    
]

(* An empty stub file is created if no push occurs so that jenkins does not fail when it 
finds no files in its out directory *)
runPush[paclet_String, version_String, origin_String, destination_String, workspace_String] := Module[{viable},
	If[origin==="localhost",
		dumpAndPushToHead[paclet, version, workspace];
		viable = CheckProductionHEADViability[paclet];
		If[viable=!=True,
    		logPrint["ERROR", "Paclet failed viability check!"];
    		Exit[1];
    	];
    	pushToProduction[paclet, "HEAD", destination];,
    	pushToProduction[paclet, origin, destination];
	];
    logPrint["INFO", "Push Finished"];
]

runBatchPrep[origin_String, destination_String, additions_List, omissions_List, workspace_String] := Module[{pushFile, dbsToPush, stagingElements},
	pushFile = FileNameJoin[{workspace, "pushfile.txt"}];
	dbsToPush = ProductionPushPrep[origin, destination][[2]];
	stagingElements = Select[dbsToPush, StringMatchQ[#, __ ~~ "staging"] &];
	If[Length[stagingElements] > 0,
		Scan[logPrint["INFO", "staging paclet "<>#<>" found!"] &, stagingElements];
		logPrint["INFO", "Adding Production Exclusions..."];
		AddProductionExclusion/@stagingElements;
		dbsToPush = Complement[dbsToPush, stagingElements];
	];
	dbsToPush = Union[dbsToPush, additions];
	dbsToPush = Complement[dbsToPush, omissions];
	logPrint["INFO","Adding the following paclets to pushfile:"];
	Scan[Print[#] &, dbsToPush];
	Put[dbsToPush, pushFile];
	logPrint["INFO","Batch Push Prep Complete!"]
]

runBatchPush[origin_String, destination_String, workspace_String] := Module[{pushFile, dbsToPush, diffs, dbsNotPushed, failedPushes},
	pushFile = FileNameJoin[{workspace, "pushfile.txt"}];
	dbsToPush = Get[pushFile];
	If[MemberQ[dbsToPush, "CalculateDataCloud"],
		logPrint["INFO","CalculateDataCloud will be run in a separate executor. Removing..."];
		dbsToPush = DeleteCases[dbsToPush,"CalculateDataCloud"];
	];
	logPrint["INFO","Initiating batch push..."];
	Scan[pushToProduction[#, origin, destination] &, dbsToPush];
	logPrint["INFO","Paclet push complete, performing validation of push..."]
	If[MemberQ[dbsToPush, "CalculateGeoIPData"],
		logPrint["INFO","Performing diff check on CalculateGeoIPData..."];
		diffs = DiffCountReportsForProductionPaclet["CalculateGeoIPData", origin, destination];
		If[Length[diffs] > 0,
			logPrint["ERROR", "Differences found in GeoIPData..."];
			Print[diffs];
			logPrint["ERROR", "Please re-run push for GeoIPData, continuing..."],
			logPrint["INFO", "No diffs found, continuing..."];
		];
		dbsToPush = DeleteCases[dbsToPush,"CalculateGeoIPData"];
	];
	logPrint["INFO","Re-running ProductionPushPrep..."];
	dbsNotPushed = ProductionPushPrep[origin, destination][[2]];
	dbsNotPushed = DeleteCases[dbsNotPushed, #] & /@ {"CalculateGeoIPData","CalculateDataCloud"};
	failedPushes = Intersection[dbsToPush, dbsNotPushed];
	If[Length[failedPushes] > 0,
		Scan[logPrint["ERROR",#<>" failed to push or was recently updated!!"] &, failedPushes];
		Exit[1];
	];
	logPrint["INFO", #<>" now shows up as a diff but did not during initial prep, consider pushing..."] & /@ dbsNotPushed;	
	logPrint["INFO","Batch Push Finished!"];
]
	
runCompile[paclet_String, version_String, workspace_String] := Module[{res, rules},
	DataPacletTools`Utilities`GetConfiguration["OutputDirectory"] = workspace;
	res = Check[rules = compilePaclet[paclet, version, workspace], $Failed];
	logPrint["INFO", "Compile output: \n", TableForm[List@@@rules], "\n\n"];
	If[(res===$Failed && paclet=!="CityData")|| Not[MatchQ[rules, {__Rule}]], 
          logPrint["ERROR", "Compile error!"]; 
          Exit[1] 
     ]; 
    logPrint["INFO", "Build Finished"];
]

runLocalize[paclet_String, version_String, workspace_String, language_String] := Module[{res, rules},
	DataPacletTools`Utilities`GetConfiguration["OutputDirectory"] = workspace;
	res = Check[rules = compileLocalizedPaclet[paclet, version, workspace, language], $Failed];
	logPrint["INFO", "Compile output: \n", TableForm[List@@@rules], "\n\n"];
	If[res===$Failed || Not[MatchQ[rules, {__Rule}]], 
          logPrint["ERROR", "Compile error!"]; 
          Exit[1] 
     ]; 
    logPrint["INFO", "Build Finished"];
    deployLocalizationToHead[paclet, version, language];
]
	
filterFiles[paclet_String, files_List] := files 

shouldCommitStub[paclet_String] := True

pacletBuildOptions[paclet_String] := Flatten[{customBuildOptions[paclet],  
    {
    "Target" -> "Calculate",
    "MathematicaVersion" -> "7.0+",
    "Storage" -> "SerializeCode" -> False
    }
},1]



(* ===========  Custom Paclet Options  =========== *)

(* CityData.m too? *)
filterFiles["CityData", files_List] := Select[files, StringFreeQ[#, "/CityIDsDB.m" | "/CityNamesDB.m" | "/CountryCities.m" | "/CityDataCountryGroups.m"]&]
 

filterFiles["CountryData", files_List] := Module[{rawsources, alphasources, skipsource, sources, first, middle, last, skipalphasource},
	rawsources=Select[files, FreeQ[#, "/Alpha/"]&];
	alphasources = Complement[files, rawsources]; 
    skipsource={ "NonCountries.m", "InternetUsers.m","UnemploymentFraction.m","CellularPhones.m",
        "PavedAirportLengths.m","UnpavedAirportLengths.m", "Religions.m","ReligionsFractions.m",
        "Organizations.m","OfficialLanguages.m","Languages.m","LanguagesFractions.m"(*, "Memberships.m", "Econ.m"*)};
    sources=Select[rawsources,StringFreeQ[#,WordBoundary~~skipsource]&];
    skipalphasource={(*"RawInternetUsers.m","RawUnemploymentFraction.m","RawGWP.m"*)"RawGNP.m"};
    alphasources=Select[alphasources,StringFreeQ[#,skipalphasource]&];
    middle=Join[sources,alphasources];
    first=Select[middle,!StringFreeQ[#,WordBoundary~~{"CountriesProperties.m","CalculateUNDataProperties.m"}]&];
    last=Select[middle,!StringFreeQ[#,WordBoundary~~{"RawNonCountries.m","NonCountries.m","Units.m","CountryData.m","CalculateCountryData.m"}]&];
    middle=Complement[middle,first,last];
    Join[first,middle,last]    
]


(* From CVS commit messages and developers. These have hand edited stubs. *)
shouldCommitStub["ExpandedFoodData"] := False
shouldCommitStub["CommonMaterialData"] := False
shouldCommitStub["WordData"] := False
shouldCommitStub["MaterialData"] := False
shouldCommitStub["ChemicalReactionData"] := False
shouldCommitStub["AlloyData"] := False
shouldCommitStub["WoodData"] := False



(* Harvested and cleaned up from info tables *)
customBuildOptions[_] := {}
customBuildOptions["ACSData"]:={"Alpha"->{"GeneralDataStub"->None, "Databases"->{"MySQL"}}, "BatchSize"->10000, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["AgricultureData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["AlloyData"]:={"Behavior"->{"EnableLookup"->True, "RankProperties"->{}, "FetchDataFromMembers"->True, "EnableEntityAttributes"->True}, "Precompute"->{"PropertyValues"->False, "MinimumMemberDataFraction"->0.}}
customBuildOptions["AstronomicalData"]:={"Grouping"->"MembershipProperty"->"Classes", "MathematicaVersion" -> "7.0+", "Miscellaneous"->{"ChunkSize"->50000}}
customBuildOptions["AtomicSpectrumData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["AutomobileData"]:={"Behavior"->{"EnableLookup"->True, "RankProperties"->{}, "FetchDataFromMembers"->True, "EnableEntityAttributes"->True}, "Naming"->{"EntityAttributeNamingFunction"->Function[{ents}, Module[{attributePriorities}, attributePriorities = {{"Year", _}->0, _String :> 1, {"Trim", _}->2, {"EngineDisplacement", _}->3, {"CylinderArrangement", _}->4, {"CylinderNumber", _}->5, {"EngineNote", _}->5.5, {"TransmissionGears", _}->6, {"TransmissionType", _}->7, {"DriveTrain", _}->8, {"Doors", _}->9, {"BodyType", _}->10}; StringJoin[Riffle[DeleteDuplicates[SortBy[ents, #1[[1]] /. attributePriorities & ][[All,2]]], " "]]]]}, "Precompute"->{"PropertyValues"->True}}
customBuildOptions["CityData"]:={"Miscellaneous"->{"ChunkSize"->100000}, "Naming"->{"InternalStandardName"->True}, "Database"->{"Engine"->{"MySQL", "HSQLDB"}}, "MathematicaVersion"->"8.0+"}
customBuildOptions["CountryData"]:={"Miscellaneous"->{"ChunkSize"->50000}, "Behavior"->"EnableLookup"->True,"Naming"->{"InternalStandardName" -> False}}
customBuildOptions["DietaryReferenceData"]:={"Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["DiseaseData"]:={"Miscellaneous"->{"ChunkSize"->5000}}
customBuildOptions["ExpandedChemicalData"]:={"Grouping"->{"PrivateMembershipLists"->{"CompoundFormulaString"}}, "Miscellaneous"->{"ChunkSize"->50000}, "Naming"->{"InternalStandardName"->True}}
customBuildOptions["ExpandedSalaryData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["FaultLineData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["FoundationData"]:={"Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["GeneData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["GenomeSequenceData"]:={"Alpha"->{"Databases"->{"MySQL"}}, "BatchSize"->1000, "Behavior"->{"EnableLookup"->False}}
customBuildOptions["HarvardCleanEnergyProjectData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["InterRidgeVentData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["MaterialData"]:={"Miscellaneous"->{"ChunkSize"->50000}, "Naming"->{"InternalStandardName"->True}}
customBuildOptions["MortalityData"]:={"Miscellaneous"->{"ChunkSize"->10000}}
customBuildOptions["MovieTimeData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["MusicalInstrumentData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["NHANESData"]:={"Database"->{"Engine"->{"MySQL"}}, "Miscellaneous"->{"ChunkSize"->100}}
customBuildOptions["PopularityData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["ProFootballData"]:={"Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["ProteinStructureData"]:={"Alpha"->{"GeneralDataStub"->Automatic, "Databases"->{"MySQL"}}, "BatchSize"->1000, "Logging"->{"ConsoleLevel"->"Info", "FileLevel"->"Info"}}
customBuildOptions["RecurringEventData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["RetailLocationData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["SNPData"]:={"Alpha"->"Databases"->{"MySQL"}, "BatchSize"->10000, "Behavior"->{"EnableLookup"->False}}
customBuildOptions["SecurityData"]:={"Miscellaneous"->{"ChunkSize"->2000, "BatchSize"->2000}}
customBuildOptions["SequenceData"]:={"Database"->{"Engine"->{"MySQL"}}, "Miscellaneous"->{"ChunkSize"->50000}, "Naming"->{"InternalStandardName"->True}}
customBuildOptions["SymptomData"]:={"Miscellaneous"->{"ChunkSize"->5000}}
customBuildOptions["TestRepoPacletData"]:={"Alpha"->{"Databases"->{"MySQL"}}}
customBuildOptions["TideData"]:={"Behavior"->"EnableLookup"->False, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["USCensusData"]:={"BatchSize"->10000}
customBuildOptions["USEconomicData"]:={"BatchSize"->10000, "Behavior"->{"EnableLookup"->True, "EnablePerEntityPropertyListing"->True, "FetchDataFromMembers"->False, "EnableEntityAttributes"->False, "RankProperties"->{}, "UsingRepositoryTimeSeries"->True}}
customBuildOptions["USPrivateSchoolData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["USPublicSchoolData"]:={"Miscellaneous"->{"ChunkSize"->50000}, "Reinitialize"->False}
customBuildOptions["WeatherData"]:={"Miscellaneous"->{"DefinitionReordering"->Automatic}}
customBuildOptions["WikipediaStatsData"]:={"Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["WoodData"]:={"Behavior"->{"EnableLookup"->True, "RankProperties"->{}, "FetchDataFromMembers"->True, "EnableEntityAttributes"->True}, "Naming"->{"EntityAttributeNamingFunction"->Function[{ents}, Module[{attributePriorities = {{"GlobalDistribution", _}->1, {"RegionalDistribution", _}->2, {"ColorDesignation", _}->3, {"Variety", _}->4, _String :> 5, {"MoistureLevel", _}->6}}, StringReplace[StringJoin[Riffle[SortBy[MapAt[StringReplace[#1, " wood" :> ""] & , ents /. {"dry"->", dry", "green"->", green"}, {1, 2}], #1[[1]] /. attributePriorities & ][[All,2]], " "]], " , " :> ", "]]]}, "Precompute"->{"PropertyValues"->True, "MinimumMemberDataFraction"->0.}}
customBuildOptions["WordData"]:={"Database"->{"Engine"->{"MySQL"}}}
customBuildOptions["ZacksAnalysisData"]:={"Alpha"->"Databases"->{"MySQL"}, "Database"->{"Engine"->{"MySQL"}}}

(* Special options for localized paclets *)
customBuildOptions["Localized"]:={"Database"->{"Engine"->{"MySQL"}}, "Miscellaneous"->{"DefinitionReordering" -> Automatic, "QuietErrors" -> False}}

End[] (* end private *)
EndPackage[]